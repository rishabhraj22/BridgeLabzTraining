## ğŸ“… Week 03 â€“ Data Structures & Algorithms  

### ğŸ—“ Day 1: Linked List (Singly, Doubly & Circular)  
Date: 2 January 2026  

#### ğŸ”¹ Topics Covered  

Singly Linked List
- Understood node structure with data and next reference  

Doubly Linked List

Circular Linked List
- Implemented circular traversal using tail.next = head  

Algorithmic Thinking
- Applied traversal-based logic  
- Compared node values and maintained counters  
- Designed efficient solutions using linked list properties  

### âœ… Practice Summary  

Solved *9 Linked Listâ€“based programs* covering Singly, Doubly, and Circular Linked Lists:

1. *Singly Linked List â€“ Student Record Management System*  
2. *Singly Linked List â€“ Inventory Management System*  
3. *Singly Linked List â€“ Social Media Friend Connections*
5. *Doubly Linked List â€“ Movie Management System*  
6. *Doubly Linked List â€“ Library Management System*  
7. *Circular Linked List â€“ Task Scheduler*  
8. *Circular Linked List â€“ Online Ticket Reservation System*  
9. *Circular Linked List â€“ Round Robin Scheduling Algorithm*  
10. *Doubly Linked List â€“ Undo/Redo Functionality for Text Editor*

ğŸ”— Code link:  
[Week 03 â€“ Linked List Programs](https://github.com/rishabhraj22/BridgeLabzTraining/tree/dsa-practice/dsa-practice/gcr-codebase/javaDSAPractice/src/com/linkedlist)

---
### ğŸ—“ Day 2: Stack, Queue & Hashing  
Date: 3 January 2026  

#### ğŸ”¹ Topics Covered  

Stacks
- LIFO behavior and use cases  
- Recursive and nested problem solving  
- Stack underflow and overflow handling  
- Efficient implementation using Java Collections  

Queues
- FIFO behavior and applications  
- Simple Queue, Deque, and Priority Queue  
- Circular queue concepts  
- Safe enqueue and dequeue operations  

Hash Maps & Hashing
- Hashing fundamentals and hash functions  
- Fast lookup using HashMap  
- Collision handling with separate chaining  
- Custom HashMap implementation  

Best Practices
- Avoided infinite recursion  
- Validated empty stack and queue operations  
- Used auxiliary data structures for optimization  

### âœ… Practice Summary  

Solved *11 Stack, Queue, and HashMapâ€“based problems*:

Stack & Queue Problems
1. Queue Using Two Stacks  
2. Sort a Stack Using Recursion  
3. Stock Span Problem  
4. Sliding Window Maximum  
5. Circular Tour (Petrol Pump Problem)  

Hash Map & Hashing Problems

6. Find All Subarrays with Zero Sum  
7. Check for a Pair with Given Sum  
8. Longest Consecutive Sequence  
9. Custom Hash Map Implementation  
10. Two Sum Problem  

ğŸ”— Code link:  
[Week 03 â€“ Stack, Queue & Hashing Programs](https://github.com/rishabhraj22/BridgeLabzTraining/tree/dsa-practice/dsa-practice/gcr-codebase/javaDSAPractice/src/com/stackqueue)

---
### ğŸ—“ Day 3: Sorting Algorithms  
Date: 5 January 2026  

#### ğŸ”¹ Topics Covered  

Sorting Fundamentals
- Understood comparison-based and non-comparison-based sorting  
- Learned time and space complexity trade-offs  
- Applied sorting logic to real-world scenarios  

Comparison-Based Sorting
- Bubble Sort  
- Insertion Sort  
- Selection Sort  
- Merge Sort  
- Quick Sort  
- Heap Sort  

Non-Comparison Sorting
- Counting Sort  

Best Practices
- Chose sorting algorithms based on data size and constraints  
- Applied stable vs unstable sorting concepts  
- Optimized performance using divide-and-conquer strategies  

### âœ… Practice Summary  

Solved *7 sorting-based problems* using different algorithms:

1. *Bubble Sort â€“ Sort Student Marks*  
2. *Insertion Sort â€“ Sort Employee IDs*  
3. *Merge Sort â€“ Sort Book Prices*  
4. *Quick Sort â€“ Sort Product Prices*  
5. *Selection Sort â€“ Sort Exam Scores*  
6. *Heap Sort â€“ Sort Job Applicants by Salary*  
7. *Counting Sort â€“ Sort Student Ages*  

ğŸ”— Code link:  
[Week 03 â€“ Sorting Algorithms](https://github.com/rishabhraj22/BridgeLabzTraining/tree/dsa-practice/dsa-practice/gcr-codebase/javaDSAPractice/src/com/sortingalgorithms)

---
### ğŸ—“ Day 4: Searching & Java Utility Classes  
**Date:** 6 January 2026  

#### ğŸ”¹ Topics Covered

##### Scenario-Based Object-Oriented Design
- Designed applications from real-world problem statements  
- Identified classes, relationships, and responsibilities  
- Applied abstraction to convert stories into system design  

##### Core OOP Concepts
- Inheritance, Interfaces, Polymorphism, Encapsulation  
- Constructors and constructor overloading  
- Access modifiers for data protection  

##### Java Utility Classes & File Handling
- StringBuilder and StringBuffer best practices  
- FileReader with BufferedReader  
- InputStreamReader for byte-to-character conversion  

##### Searching Algorithms
- Linear Search for unsorted data  
- Binary Search for sorted data  
- Applied early return and bounds checking techniques  


#### ğŸ”¹ Scenario-Based Applications Implemented

1. **EduMentor â€“ Personalized Learning Platform**  
2. **FitTrack â€“ Your Personal Fitness Tracker**  
3. **PetPal â€“ Virtual Pet Care App**  
4. **EventEase â€“ Event Management Platform**  


#### ğŸ”¹ Java Utility & File Handling Problems

- Reverse a string using **StringBuilder**  
- Remove duplicates using **StringBuilder**  
- Efficient string concatenation using **StringBuffer**  
- Performance comparison: **StringBuffer vs StringBuilder**  
- Read file line by line using **FileReader**  
- Count word occurrences using **FileReader**  
- Convert byte stream using **InputStreamReader**  
- Read console input and write to file using **InputStreamReader**


#### ğŸ”¹ Searching Problems Implemented

### Linear Search
- Find first negative number in an array  
- Search a word in a list of sentences  

##### Binary Search
- Find rotation point in rotated sorted array  
- Find a peak element in an array  
- Search target in 2D sorted matrix  
- Find first and last occurrence in sorted array  

##### Challenge
- First missing positive integer (Linear Search)  
- Target index after sorting (Binary Search)  

#### ğŸ§  Best Practices Applied

- Used **StringBuilder** for mutable strings in loops  
- Used **StringBuffer** where thread safety is required  
- Wrapped file readers with **BufferedReader**  
- Ensured sorted data before applying **Binary Search**  
- Applied **encapsulation** for sensitive data  
- Designed clean and maintainable class structures  

#### âœ… Practice Summary

Completed **4 scenario-based applications** and solved **multiple searching & utility problems** focusing on:
- OOP design  
- File handling  
- Performance optimization  
- Efficient searching techniques  

ğŸ”— Code link:  
[Week 03 â€“ Searching Algorithms](https://github.com/rishabhraj22/BridgeLabzTraining/tree/dsa-practice/dsa-practice/gcr-codebase/javaDSAPractice/src/com/Searching)

---

### ğŸ—“ Day 5: Runtime Analysis & Big-O Notation  
**Date:** 7 January 2026  


#### ğŸ”¹ Topics Covered

##### Scenario-Based Object-Oriented Design
- Designed systems based on real-world problem statements  
- Identified entities, relationships, and responsibilities  
- Applied abstraction to convert stories into system architecture  

##### Core OOP Concepts
- Inheritance for building class hierarchies  
- Interfaces for defining common behavior  
- Polymorphism for dynamic method execution  
- Encapsulation to protect sensitive and internal data  
- Constructors and constructor overloading for flexible object creation  
- Access modifiers for controlled data access  

##### Algorithm Runtime Analysis & Big-O Notation
- Understood time and space complexity trade-offs  
- Analyzed algorithm performance for large datasets  
- Compared recursive vs iterative approaches  
- Evaluated performance of different data structures  
- Applied best practices for writing efficient code  


#### ğŸ”¹ Scenario-Based Applications Implemented

1. **ParkEase â€“ Smart Parking Management System**  
2. **LoanBuddy â€“ Loan Approval Automation**  
3. **BookBazaar â€“ Digital Bookstore System**  


#### ğŸ”¹ Scenario Details

##### 1. ParkEase â€“ Smart Parking Management System
- Base class: `Vehicle` â†’ subclasses `Car`, `Bike`, `Truck`  
- `ParkingSlot` class with slotId, occupancy status, vehicle type allowed  
- Interface: `IPayable` with `calculateCharges(duration)`  
- Encapsulation of slot availability and internal booking records  
- Constructors for slot initialization with location and vehicle type  
- Operators used: `(baseRate Ã— hours) + penalty`  
- Polymorphism in charge calculation based on vehicle type  

##### 2. LoanBuddy â€“ Loan Approval Automation
- `Applicant` class with name, creditScore, income, loanAmount  
- `LoanApplication` class with loan type, term, interest rate  
- Interface: `IApprovable` with `approveLoan()` and `calculateEMI()`  
- Inheritance: `HomeLoan`, `AutoLoan` extending base loan class  
- Polymorphism for EMI calculation logic  
- EMI formula applied: `P Ã— R Ã— (1+R)^N / ((1+R)^N â€“ 1)`  
- Encapsulation of credit score and internal approval logic  
- Access control for loan status updates  

##### 3. BookBazaar â€“ Digital Bookstore System
- `Book` base class â†’ `EBook`, `PrintedBook` subclasses  
- `Order` class linking users and books  
- Interface: `IDiscountable` with `applyDiscount()`  
- Encapsulation of inventory count  
- Constructors with optional offers  
- Operators used: `price Ã— quantity â€“ discount`  
- Polymorphism in discount application  
- Restricted order status updates using access modifiers  


#### ğŸ”¹ Runtime Analysis & Big-O Practice

##### Performance Comparisons Implemented

- **Linear Search vs Binary Search**
  - O(N) vs O(log N) performance on large datasets  
  - Observed Binary Search is significantly faster for sorted data  

- **Sorting Algorithms Comparison**
  - Bubble Sort (O(NÂ²))  
  - Merge Sort (O(N log N))  
  - Quick Sort (O(N log N))  
  - Identified Bubble Sort as impractical for large datasets  

- **String Concatenation Performance**
  - String (O(NÂ²))  
  - StringBuilder (O(N))  
  - StringBuffer (O(N))  
  - Observed StringBuilder as fastest in single-threaded context  

- **File Reading Efficiency**
  - FileReader vs InputStreamReader  
  - InputStreamReader performed better for large files  

- **Recursive vs Iterative Fibonacci**
  - Recursive: O(2â¿) (inefficient)  
  - Iterative: O(N) (efficient and scalable)  

- **Data Structure Search Comparison**
  - Array: O(N)  
  - HashSet: O(1)  
  - TreeSet: O(log N)  
  - HashSet observed as fastest for lookups  


#### ğŸ§  Best Practices Applied

- Chose correct data structures based on use case  
- Avoided unnecessary nested loops  
- Used early return to reduce iterations  
- Preferred iterative solutions over expensive recursion  
- Used StringBuilder instead of String for concatenation  
- Used HashSet for fast lookups  
- Designed OOP systems with clean separation of concerns  
- Protected sensitive data using encapsulation  

---

#### âœ… Practice Summary

Implemented **3 complete scenario-based OOP applications** and performed **in-depth runtime analysis** on multiple algorithms and data structures:

##### Scenario-Based Applications
1. ParkEase â€“ Smart Parking Management System  
2. LoanBuddy â€“ Loan Approval Automation  
3. BookBazaar â€“ Digital Bookstore System  

##### Runtime Analysis & Big-O
- Searching algorithms comparison  
- Sorting algorithms comparison  
- String performance benchmarking  
- File reading performance testing  
- Recursive vs iterative analysis  
- Data structure efficiency comparison  

This day focused on **system design + performance optimization + algorithmic efficiency**.

#### ğŸ”— Code link:  
[Week 03 â€“ Runtime Analysis & Big-O Notation](https://github.com/rishabhraj22/BridgeLabzTraining/tree/dsa-practice/dsa-practice/gcr-codebase/javaDSAPractice/src/com/runtimeanalysisandbigonotation)

---
